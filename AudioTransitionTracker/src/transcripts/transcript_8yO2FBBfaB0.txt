timestamp 0: Here's how our virtual memory system will
work.
timestamp 3: The memory addresses generated by the CPU
are called virtual addresses to distinguish
timestamp 8: them from the physical addresses used by main
memory.
timestamp 12: In between the CPU and main memory there's
a new piece of hardware called the memory
timestamp 16: management unit (MMU).
timestamp 20: The MMU's job is to translate virtual addresses
to physical addresses.
timestamp 24: "But wait!" you say.
timestamp 26: "Doesn't the cache go between the CPU and
main memory?"
timestamp 31: You're right and at the end of this lecture
we'll talk about how to use both an MMU and
timestamp 35: a cache.
timestamp 36: But for now, let's assume there's only an
MMU and no cache.
timestamp 42: The MMU hardware translates virtual addresses
to physical addresses using a simple table
timestamp 47: lookup.
timestamp 48: This table is called the page map or page
table.
timestamp 51: Conceptually, the MMU uses the virtual address
as index to select an entry in the table,
timestamp 57: which tells us the corresponding physical
address.
timestamp 61: The table allows a particular virtual address
to be found anywhere in main memory.
timestamp 66: In normal operation we'd want to ensure that
two virtual addresses don't map to the same
timestamp 70: physical address.
timestamp 73: But it would be okay if some of the virtual
addresses did not have a translation to a
timestamp 77: physical address.
timestamp 79: This would indicate that the contents of the
requested virtual address haven't yet been
timestamp 83: loaded into main memory, so the MMU would
signal a memory-management exception to the
timestamp 89: CPU,
which could assign a location in physical
timestamp 92: memory and perform the required I/O operation
to initialize that location from secondary
timestamp 97: storage.
timestamp 100: The MMU table gives the system a lot of control
over how physical memory is accessed by the
timestamp 105: program running on the CPU.
timestamp 107: For example, we could arrange to run multiple
programs in quick succession (a technique
timestamp 113: called time sharing) by changing the page
map when we change programs.
timestamp 119: Main memory locations accessible to one program
could be made inaccessible to another program
timestamp 124: by proper management of their respective page
maps.
timestamp 127: And we could use memory-management exceptions
to load program contents into main memory
timestamp 132: on demand instead of having to load the entire
program before execution starts.
timestamp 137: In fact, we only need to ensure the current
working set of a program is actually resident
timestamp 143: in main memory.
timestamp 145: Locations not currently being used could live
in secondary storage until needed.
timestamp 150: In this lecture and next, we'll see how the
MMU plays a central role in the design of
timestamp 155: a modern timesharing computer system.
timestamp 159: Of course, we'd need an impossibly large table
to separately map each virtual address to
timestamp 164: a physical address.
timestamp 166: So instead we divide both the virtual and
physical address spaces into fixed-sized blocks,
timestamp 171: called pages.
timestamp 173: Page sizes are always a power-of-2 bytes,
say 2^p bytes, so p is the number address
timestamp 180: bits needed to select a particular location
on the page.
timestamp 183: We'll the use low-order p bits of the virtual
or physical address as the page offset.
timestamp 189: The remaining address bits tell us which page
is being accessed and are called the page
timestamp 194: number.
timestamp 195: A typical page size is 4KB to 16KB, which
correspond to p=12 and p=14 respectively.
timestamp 205: Suppose p=12.
timestamp 206: If the CPU produces a 32-bit virtual address,
the low-order 12 bits of the virtual address
timestamp 213: are the page offset and the high-order 20
bits are the virtual page number.
timestamp 218: Similarly, the low-order p bits of the physical
address are the page offset and the remaining
timestamp 224: physical address bits are the physical page
number.
timestamp 228: The key idea is that the MMU will manage pages,
not individual locations.
timestamp 234: We'll move entire pages from secondary storage
into main memory.
timestamp 238: By the principal of locality, if a program
access one location on a page, we expect it
timestamp 244: will soon access other nearby locations.
timestamp 248: By choosing the page offset from the low-order
address bits, we'll ensure that nearby locations
timestamp 253: live on the same page (unless of course we're
near one end of the page or the other).
timestamp 259: So pages naturally capture the notion of locality.
timestamp 262: And since pages are large, by dealing with
pages when accessing secondary storage,
timestamp 267: we'll take advantage that reading or writing
many locations is only slightly more time
timestamp 272: consuming than accessing the first location.
timestamp 276: The MMU will map virtual page numbers to physical
page numbers.
timestamp 281: It does this by using the virtual page number
(VPN) as an index into the page table.
timestamp 287: Each entry in the page table indicates if
the page is resident in main memory and, if
timestamp 292: it is, provides the appropriate physical page
number (PPN).
timestamp 296: The PPN is combined with the page offset to
form the physical address for main memory.
timestamp 303: If the requested virtual page is NOT resident
in main memory, the MMU signals a memory-management
timestamp 310: exception, called a page fault, to the CPU
so it can load the appropriate page from secondary
timestamp 315: storage and set up the appropriate mapping
in the MMU.
timestamp 320: Our plan to use main memory as page cache
is called "paging" or sometimes "demand paging"
timestamp 326: since movements of pages to and from secondary
storage is determined by the demands of the
timestamp 331: program.
timestamp 333: So here's the plan.
timestamp 335: Initially all the virtual pages for a program
reside in secondary storage and the MMU is
timestamp 340: empty, i.e., there are no pages resident in
physical memory.
timestamp 345: The CPU starts running the program and each
virtual address it generates, either for an
timestamp 349: instruction fetch or data access, is passed
to the MMU to be mapped to a physical address
timestamp 355: in main memory.
timestamp 357: If the virtual address is resident in physical
memory, the main memory hardware can complete
timestamp 361: the access.
timestamp 364: If the virtual address in NOT resident in
physical memory, the MMU signals a page fault
timestamp 369: exception, forcing the CPU to switch execution
to special code called the page fault handler.
timestamp 376: The handler allocates a physical page to hold
the requested virtual page and loads the virtual
timestamp 382: page from secondary storage into main memory.
timestamp 386: It then adjusts the page map entry for the
requested virtual page to show that it is
timestamp 390: now resident and to indicate the physical
page number for the newly allocated and initialized
timestamp 396: physical page.
timestamp 399: When trying to allocate a physical page, the
handler may discover that all physical pages
timestamp 404: are currently in use.
timestamp 405: In this case it chooses an existing page to
replace, e.g., a resident virtual page that
timestamp 412: hasn't been recently accessed.
timestamp 415: It swaps the contents of the chosen virtual
page out to secondary storage and updates
timestamp 420: the page map entry for the replaced virtual
page to indicate it is no longer resident.
timestamp 425: Now there's a free physical page to re-use
to hold the contents of the virtual page that
timestamp 430: was missing.
timestamp 433: The working set of the program, i.e., the
set of pages the program is currently accessing,
timestamp 438: is loaded into main memory through a series
of page faults.
timestamp 443: After a flurry of page faults when the program
starts running, the working set changes slowly,
timestamp 449: so the frequency of page faults drops dramatically,
perhaps close to zero if the program is small
timestamp 454: and well-behaved.
timestamp 457: It is possible to write programs that consistently
generate page faults, a phenomenon called
timestamp 462: thrashing.
timestamp 463: Given the long access times of secondary storage,
a program that's thrashing runs *very* slowly,
timestamp 470: usually so slowly that users give up and rewrite
the program to behave more sensibly.
timestamp 477: The design of the page map is straightforward.
timestamp 480: There's one entry in the page map for each
virtual page.
timestamp 483: For example, if the CPU generates a 32-bit
virtual address and the page size is 2^12
timestamp 489: bytes, the virtual page number has 32-12 = 20
bits and the page table will have 2^20 entries.
timestamp 499: Each entry in the page table contains a "resident
bit" (R) which is set to 1 when the virtual
timestamp 505: page is resident in physical memory.
timestamp 507: If R is 0, an access to that virtual page
will cause a page fault.
timestamp 513: If R is 1, the entry also contains the PPN,
indicating where to find the virtual page
timestamp 520: in main memory.
timestamp 523: There's one additional state bit called the
"dirty bit" (D).
timestamp 527: When a page has just been loaded from secondary
storage, it's "clean", i.e, the contents of
timestamp 533: physical memory match the contents of the
page in secondary storage.
timestamp 538: So the D bit is set to 0.
timestamp 541: If subsequently the CPU stores into a location
on the page, the D bit for the page is set
timestamp 546: to 1, indicating the page is "dirty", i.e.,
the contents of memory now differ from the
timestamp 552: contents of secondary storage.
timestamp 555: If a dirty page is ever chosen for replacement,
its contents must be written to secondary
timestamp 560: storage in order to save the changes before
the page gets reused.
timestamp 566: Some MMUs have additional state bits in each
page table entry.
timestamp 570: For example, there could be a "read-only"
bit which, when set, would generate an exception
timestamp 575: if the program attempts to store into the
page.
timestamp 578: This would be useful for protecting code pages
from accidentally being corrupted by errant
timestamp 583: data accesses, a very handy debugging feature.
timestamp 587: Here's an example of the MMU in action.
timestamp 590: To make things simple, assume that the virtual
address is 12 bits, consisting of an 8-bit
timestamp 596: page offset and a 4-bit virtual page number.
timestamp 599: So there are 2^4 = 16 virtual pages.
timestamp 603: The physical address is 11 bits, divided into
the same 8-bit page offset and a 3-bit physical
timestamp 610: page number.
timestamp 611: So there are 2^3 = 8 physical pages.
timestamp 616: On the left we see a diagram showing the contents
of the 16-entry page map, i.e., an entry for
timestamp 621: each virtual page.
timestamp 624: Each page table entry includes a dirty bit
(D), a resident bit (R) and a 3-bit physical
timestamp 630: page number, for a total of 5 bits.
timestamp 633: So the page map has 16 entries, each with
5-bits, for a total of 16*5 = 80 bits.
timestamp 641: The first entry in the table is for virtual
page 0, the second entry for virtual page
timestamp 645: 1, and so on.
timestamp 649: In the middle of the slide there's a diagram
of physical memory showing the 8 physical
timestamp 653: pages.
timestamp 654: The annotation for each physical page shows
the virtual page number of its contents.
timestamp 661: Note that there's no particular order to how
virtual pages are stored in physical memory
timestamp 665: -
which page holds what is determined by which
timestamp 668: pages are free at the time of a page fault.
timestamp 671: In general, after the program has run for
a while, we'd expected to find the sort of
timestamp 676: jumbled ordering we see here.
timestamp 680: Let's follow along as the MMU handles the
request for virtual address 0x2C8, generated
timestamp 686: by the execution of the LD instruction shown
here.
timestamp 690: Splitting the virtual address into page number
and offset, we see that the VPN is 2 and the
timestamp 696: offset is 0xC8.
timestamp 700: Looking at the page map entry with index 2,
we see that the R bit is 1, indicating that
timestamp 706: virtual page 2 is resident in physical memory.
timestamp 710: The PPN field of entry tells us that virtual
page 2 can be found in physical page 4.
timestamp 718: Combining the PPN with the 8-bit offset, we
find that the contents of virtual address
timestamp 724: 0x2C8 can be found in main memory location
0x4C8.
timestamp 729: Note that the offset is unchanged by the translation
process -
timestamp 733: the offset into the physical page is always
the same as the offset into the virtual page.
